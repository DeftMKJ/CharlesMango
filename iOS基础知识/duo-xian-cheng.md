# 多线程

### 1. 介绍

<figure><img src=".gitbook/assets/截屏2023-12-23 23.20.49.png" alt=""><figcaption></figcaption></figure>

### 2. GCD

用同步的方式执行任务

`dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`

用异步的方式执行任务

`dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`

<figure><img src=".gitbook/assets/截屏2023-12-24 16.49.53.png" alt=""><figcaption></figcaption></figure>



### 3. 线程同步

加锁性能从高到低

* os\_unfair\_lock
* OSSpinLock
* dispatch\_semaphore
* pthread\_mutex
* dispatch\_queue(DISPATCH\_QUEUE\_SERIAL)
* NSLock
* NSCondition
* pthread\_mutex(recursive)
* NSRecursiveLock
* NSConditionLock
* @synchronized

互斥锁和自旋锁

什么情况下使用自旋锁比较划算？

* 线程等待时间短
* 加锁的代码（临界区）经常被访问，但是竞争情况很少发生
* CPU资源不紧张
* 多核处理器

什么情况下使用互斥锁比较划算？

* 线程等待时间长
* 单核处理器
* 临界区有IO操作
* 临界区代码复杂或者循环量大
* 临界区竞争理解

### 4. 读写安全方案

* 同一时间，只能允许一个线程进行写的操作
* 同一时间，允许多个线程进行读的操作
* 同一时间，不允许既有写，又有读的操作

多读单写，经常用于文件等数据的读写操作，iOS中有

* pthread\_rwlock：读写锁
* dispatch\_barrier\_async：异步栅栏调用



###

###

### X. 总结

介绍下进程和线程。

进程和线程都是操作系统进行资源调度的基本单位，但它们之间有一些关键的区别：

1. 进程： 进程是操作系统进行资源分配的基本单位，它是一个程序关于某个数据集合上的一次运行活动。每个进程都有自己的独立的内存空间，包括代码区、数据区和堆栈区等。进程间的数据是相互独立的，一个进程无法直接访问另一个进程的数据，进程间的通信（IPC）需要使用特定的操作系统 API。
2. 线程： 线程是操作系统进行任务调度的基本单位，它是在进程内部独立执行的控制流。一个进程可以包含多个线程，这些线程共享进程的资源，如内存空间、文件句柄等。线程间的数据是共享的，一个线程可以直接访问同一进程中另一个线程的数据。

进程和线程的关系： 一个进程可以包含一个或多个线程，线程是在进程内部独立执行的控制流。线程共享进程的资源，但有自己的程序计数器、一组寄存器和栈。多线程可以实现在一个进程内部的任务并发执行，提高程序的执行效率。

总的来说，进程和线程都是操作系统进行任务调度的基本单位，进程主要用于资源分配，线程主要用于任务调度。在实际开发中，可以根据具体需求选择适当的并发模型，如单进程单线程、单进程多线程或多进程多线程等。





说下你理解的多线程？

多线程是指在一个程序中同时运行多个线程以完成多个任务的技术。线程是操作系统调度的基本单位，它是在进程内部独立执行的控制流。一个进程可以包含多个线程，这些线程共享进程的资源，如内存空间、文件句柄等。多线程可以提高程序的执行效率，使得程序能够在多核处理器上更好地利用硬件资源。

多线程的主要优点：

1. 提高程序的并发性：通过多线程技术，可以让程序在同一时刻执行多个任务，从而提高程序的执行效率。
2. 更好地利用多核处理器：现代计算机普遍具有多核处理器，多线程技术可以充分利用多核处理器的优势，使程序在多核处理器上实现并行执行，进一步提高执行效率。
3. 提高用户体验：在一些需要长时间执行的任务中，通过多线程技术，可以将耗时任务放在后台线程中执行，避免阻塞主线程，从而提高用户体验。

然而，多线程编程也带来了一些挑战：

1. 线程安全：多个线程可能会同时访问和修改共享资源，如果没有正确地同步和保护这些资源，可能会导致数据不一致、程序崩溃等问题。
2. 线程同步：多个线程之间可能需要进行通信和协作，需要使用锁、信号量等同步机制来实现。
3. 线程管理：线程的创建、销毁和调度都需要一定的资源开销，过多的线程可能会导致性能下降，因此需要合理地管理线程数量。
4. 死锁和活锁：在多线程编程中，不恰当的同步和资源竞争可能导致死锁（两个或多个线程互相等待对方释放资源，导致无法继续执行）和活锁（线程在尝试解决问题时，反复执行相同的操作，导致无法继续执行）的问题。

在实际开发中，可以根据具体需求选择合适的多线程方案，如 GCD、NSOperationQueue 等，以简化多线程编程的复杂性。同时，需要注意线程安全、线程同步和线程管理等问题，确保程序的稳定性和性能。



iOS的多线程方案有哪几种？你更倾向于哪一种？

* pthread
* NSThread
* NSOperation
* GCD

说一下 OperationQueue 和 GCD 的区别，以及各自的优势

OperationQueue 和 GCD（Grand Central Dispatch）都是用于处理并发编程和多线程任务的技术，但它们之间存在一些差异，并且各自有自己的优势。

1. OperationQueue： OperationQueue 是基于 NSOperation 和 NSOperationQueue 类实现的高级抽象。它支持任务之间的依赖关系、任务的优先级以及任务的取消等功能。

优势：

* 提供更高级别的抽象，使得代码更易于阅读和维护。
* 支持任务之间的依赖关系，可以轻松地控制任务的执行顺序。
* 可以设置任务的优先级，从而控制任务的执行顺序。
* 提供了取消任务的功能，可以方便地取消尚未执行的任务。
* 可以通过 KVO（Key-Value Observing）观察任务的状态，例如是否正在执行、是否已完成等。

2. GCD（Grand Central Dispatch）： GCD 是一种低级别的 C 语言 API，基于 C 语言的 dispatch 库实现。它提供了对线程池的自动管理以及对并发队列的支持，使得在多核硬件上实现并发变得简单高效。

优势：

* 性能较高，因为它是基于 C 语言实现的，没有 Objective-C 的运行时开销。
* 简化了线程管理，自动处理线程池，避免了手动创建和管理线程的复杂性。
* 提供了多种队列类型，如串行队列、并发队列和主队列，方便实现不同类型的并发需求。
* 支持延迟执行、分组任务等特性，方便实现复杂的并发逻辑。
* 跨平台支持，可以在 iOS、macOS 以及其他支持 dispatch 库的平台上使用。



* OC你了解的锁有哪些？在你回答基础上进行二次提问；
* 追问一：自旋和互斥对比？
* 追问二：使用以上锁需要注意哪些？
* 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！
